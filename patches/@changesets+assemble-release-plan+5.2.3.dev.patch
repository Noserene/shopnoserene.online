diff --git a/node_modules/@changesets/assemble-release-plan/.DS_Store b/node_modules/@changesets/assemble-release-plan/.DS_Store
new file mode 100644
index 0000000..c88a062
Binary files /dev/null and b/node_modules/@changesets/assemble-release-plan/.DS_Store differ
diff --git a/node_modules/@changesets/assemble-release-plan/dist/assemble-release-plan.cjs.dev.js b/node_modules/@changesets/assemble-release-plan/dist/assemble-release-plan.cjs.dev.js
index 3a37c62..dd25388 100644
--- a/node_modules/@changesets/assemble-release-plan/dist/assemble-release-plan.cjs.dev.js
+++ b/node_modules/@changesets/assemble-release-plan/dist/assemble-release-plan.cjs.dev.js
@@ -5,79 +5,64 @@ Object.defineProperty(exports, '__esModule', { value: true });
 var semver = require('semver');
 var errors = require('@changesets/errors');
 var getDependentsGraph = require('@changesets/get-dependents-graph');
+var resolveFrom = require('resolve-from');
+var path = require('path');
 
 function _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }
 
 var semver__default = /*#__PURE__*/_interopDefault(semver);
-
-function _defineProperty(obj, key, value) {
-  if (key in obj) {
-    Object.defineProperty(obj, key, {
-      value: value,
-      enumerable: true,
-      configurable: true,
-      writable: true
-    });
-  } else {
-    obj[key] = value;
-  }
-
-  return obj;
-}
+var resolveFrom__default = /*#__PURE__*/_interopDefault(resolveFrom);
+var path__default = /*#__PURE__*/_interopDefault(path);
 
 function ownKeys(object, enumerableOnly) {
   var keys = Object.keys(object);
-
   if (Object.getOwnPropertySymbols) {
     var symbols = Object.getOwnPropertySymbols(object);
-    if (enumerableOnly) symbols = symbols.filter(function (sym) {
+    enumerableOnly && (symbols = symbols.filter(function (sym) {
       return Object.getOwnPropertyDescriptor(object, sym).enumerable;
-    });
-    keys.push.apply(keys, symbols);
+    })), keys.push.apply(keys, symbols);
   }
-
   return keys;
 }
-
 function _objectSpread2(target) {
   for (var i = 1; i < arguments.length; i++) {
-    var source = arguments[i] != null ? arguments[i] : {};
-
-    if (i % 2) {
-      ownKeys(Object(source), true).forEach(function (key) {
-        _defineProperty(target, key, source[key]);
-      });
-    } else if (Object.getOwnPropertyDescriptors) {
-      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
-    } else {
-      ownKeys(Object(source)).forEach(function (key) {
-        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
-      });
-    }
+    var source = null != arguments[i] ? arguments[i] : {};
+    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {
+      _defineProperty(target, key, source[key]);
+    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {
+      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
+    });
   }
-
   return target;
 }
+function _defineProperty(obj, key, value) {
+  if (key in obj) {
+    Object.defineProperty(obj, key, {
+      value: value,
+      enumerable: true,
+      configurable: true,
+      writable: true
+    });
+  } else {
+    obj[key] = value;
+  }
+  return obj;
+}
 
 function incrementVersion(release, preInfo) {
   if (release.type === "none") {
     return release.oldVersion;
   }
-
   let version = semver.inc(release.oldVersion, release.type);
-
   if (preInfo !== undefined && preInfo.state.mode !== "exit") {
     let preVersion = preInfo.preVersions.get(release.name);
-
     if (preVersion === undefined) {
       throw new errors.InternalError(`preVersion for ${release.name} does not exist when preState is defined`);
-    } // why are we adding this ourselves rather than passing 'pre' + versionType to semver.inc?
+    }
+    // why are we adding this ourselves rather than passing 'pre' + versionType to semver.inc?
     // because semver.inc with prereleases is confusing and this seems easier
-
-
     version += `-${preInfo.state.tag}.${preVersion}`;
   }
-
   return version;
 }
 
@@ -93,7 +78,6 @@ function incrementVersion(release, preInfo) {
   We could solve this by inlining this function, or by returning a deep-cloned then
   modified array, but we decided both of those are worse than this solution.
 */
-
 function determineDependents({
   releases,
   packagesByName,
@@ -101,31 +85,26 @@ function determineDependents({
   preInfo,
   config
 }) {
-  let updated = false; // NOTE this is intended to be called recursively
-
+  let updated = false;
+  // NOTE this is intended to be called recursively
   let pkgsToSearch = [...releases.values()];
-
   while (pkgsToSearch.length > 0) {
     // nextRelease is our dependency, think of it as "avatar"
     const nextRelease = pkgsToSearch.shift();
-    if (!nextRelease) continue; // pkgDependents will be a list of packages that depend on nextRelease ie. ['avatar-group', 'comment']
-
+    if (!nextRelease) continue;
+    // pkgDependents will be a list of packages that depend on nextRelease ie. ['avatar-group', 'comment']
     const pkgDependents = dependencyGraph.get(nextRelease.name);
-
     if (!pkgDependents) {
       throw new Error(`Error in determining dependents - could not find package in repository: ${nextRelease.name}`);
     }
-
     pkgDependents.map(dependent => {
       let type;
       const dependentPackage = packagesByName.get(dependent);
       if (!dependentPackage) throw new Error("Dependency map is incorrect");
-
       if (config.ignore.includes(dependent)) {
         type = "none";
       } else {
         const dependencyVersionRanges = getDependencyVersionRanges(dependentPackage.packageJson, nextRelease);
-
         for (const {
           depType,
           versionRange
@@ -150,9 +129,7 @@ function determineDependents({
                 if (type !== "major" && type !== "minor") {
                   type = "patch";
                 }
-
                 break;
-
               case "devDependencies":
                 {
                   // We don't need a version bump if the package is only in the devDependencies of the dependent package
@@ -164,11 +141,9 @@ function determineDependents({
           }
         }
       }
-
       if (releases.has(dependent) && releases.get(dependent).type === type) {
         type = undefined;
       }
-
       return {
         name: dependent,
         type,
@@ -181,7 +156,8 @@ function determineDependents({
     }) => {
       // At this point, we know if we are making a change
       updated = true;
-      const existing = releases.get(name); // For things that are being given a major bump, we check if we have already
+      const existing = releases.get(name);
+      // For things that are being given a major bump, we check if we have already
       // added them here. If we have, we update the existing item instead of pushing it on to search.
       // It is safe to not add it to pkgsToSearch because it should have already been searched at the
       // largest possible bump type.
@@ -201,31 +177,29 @@ function determineDependents({
       }
     });
   }
-
   return updated;
 }
+
 /*
   Returns an array of objects in the shape { depType: DependencyType, versionRange: string }
   The array can contain more than one elements in case a dependency appears in multiple
   dependency lists. For example, a package that is both a peerDepenency and a devDependency.
 */
-
 function getDependencyVersionRanges(dependentPkgJSON, dependencyRelease) {
   const DEPENDENCY_TYPES = ["dependencies", "devDependencies", "peerDependencies", "optionalDependencies"];
   const dependencyVersionRanges = [];
-
   for (const type of DEPENDENCY_TYPES) {
     var _dependentPkgJSON$typ;
-
     const versionRange = (_dependentPkgJSON$typ = dependentPkgJSON[type]) === null || _dependentPkgJSON$typ === void 0 ? void 0 : _dependentPkgJSON$typ[dependencyRelease.name];
     if (!versionRange) continue;
-
     if (versionRange.startsWith("workspace:")) {
       dependencyVersionRanges.push({
         depType: type,
-        versionRange: // intentionally keep other workspace ranges untouched
+        versionRange:
+        // intentionally keep other workspace ranges untouched
         // this has to be fixed but this should only be done when adding appropriate tests
-        versionRange === "workspace:*" ? // workspace:* actually means the current exact version, and not a wildcard similar to a reguler * range
+        versionRange === "workspace:*" ?
+        // workspace:* actually means the current exact version, and not a wildcard similar to a reguler * range
         dependencyRelease.oldVersion : versionRange.replace(/^workspace:/, "")
       });
     } else {
@@ -235,10 +209,8 @@ function getDependencyVersionRanges(dependentPkgJSON, dependencyRelease) {
       });
     }
   }
-
   return dependencyVersionRanges;
 }
-
 function shouldBumpMajor({
   dependent,
   depType,
@@ -249,18 +221,22 @@ function shouldBumpMajor({
   onlyUpdatePeerDependentsWhenOutOfRange
 }) {
   // we check if it is a peerDependency because if it is, our dependent bump type might need to be major.
-  return depType === "peerDependencies" && nextRelease.type !== "none" && nextRelease.type !== "patch" && ( // 1. If onlyUpdatePeerDependentsWhenOutOfRange set to true, bump major if the version is leaving the range.
+  return depType === "peerDependencies" && nextRelease.type !== "none" && nextRelease.type !== "patch" && (
+  // 1. If onlyUpdatePeerDependentsWhenOutOfRange set to true, bump major if the version is leaving the range.
   // 2. If onlyUpdatePeerDependentsWhenOutOfRange set to false, bump major regardless whether or not the version is leaving the range.
-  !onlyUpdatePeerDependentsWhenOutOfRange || !semver__default['default'].satisfies(incrementVersion(nextRelease, preInfo), versionRange)) && ( // bump major only if the dependent doesn't already has a major release.
+  !onlyUpdatePeerDependentsWhenOutOfRange || !semver__default['default'].satisfies(incrementVersion(nextRelease, preInfo), versionRange)) && (
+  // bump major only if the dependent doesn't already has a major release.
   !releases.has(dependent) || releases.has(dependent) && releases.get(dependent).type !== "major");
 }
 
 // This function takes in changesets and returns one release per
 // package listed in the changesets
+
 function flattenReleases(changesets, packagesByName, ignoredPackages) {
   let releases = new Map();
   changesets.forEach(changeset => {
-    changeset.releases // Filter out ignored packages because they should not trigger a release
+    changeset.releases
+    // Filter out ignored packages because they should not trigger a release
     // If their dependencies need updates, they will be added to releases by `determineDependents()` with release type `none`
     .filter(({
       name
@@ -270,11 +246,9 @@ function flattenReleases(changesets, packagesByName, ignoredPackages) {
     }) => {
       let release = releases.get(name);
       let pkg = packagesByName.get(name);
-
       if (!pkg) {
         throw new Error(`"${changeset.id}" changeset mentions a release for a package "${name}" but such a package could not be found.`);
       }
-
       if (!release) {
         release = {
           name,
@@ -285,14 +259,12 @@ function flattenReleases(changesets, packagesByName, ignoredPackages) {
       } else {
         if (type === "major" || (release.type === "patch" || release.type === "none") && (type === "minor" || type === "patch")) {
           release.type = type;
-        } // Check whether the bumpType will change
+        }
+        // Check whether the bumpType will change
         // If the bumpType has changed recalc newVersion
         // push new changeset to releases
-
-
         release.changesets.push(changeset.id);
       }
-
       releases.set(name, release);
     });
   });
@@ -303,64 +275,52 @@ function getHighestReleaseType(releases) {
   if (releases.length === 0) {
     throw new Error(`Large internal Changesets error when calculating highest release type in the set of releases. Please contact the maintainers`);
   }
-
   let highestReleaseType = "none";
-
   for (let release of releases) {
     switch (release.type) {
       case "major":
         return "major";
-
       case "minor":
         highestReleaseType = "minor";
         break;
-
       case "patch":
         if (highestReleaseType === "none") {
           highestReleaseType = "patch";
         }
-
         break;
     }
   }
-
   return highestReleaseType;
 }
 function getCurrentHighestVersion(packageGroup, packagesByName) {
   let highestVersion;
-
   for (let pkgName of packageGroup) {
     let pkg = packagesByName.get(pkgName);
-
     if (!pkg) {
       console.error(`FATAL ERROR IN CHANGESETS! We were unable to version for package group: ${pkgName} in package group: ${packageGroup.toString()}`);
       throw new Error(`fatal: could not resolve linked packages`);
     }
-
     if (highestVersion === undefined || semver__default['default'].gt(pkg.packageJson.version, highestVersion)) {
       highestVersion = pkg.packageJson.version;
     }
   }
-
   return highestVersion;
 }
 
 function matchFixedConstraint(releases, packagesByName, config) {
   let updated = false;
-
   for (let fixedPackages of config.fixed) {
     let releasingFixedPackages = [...releases.values()].filter(release => fixedPackages.includes(release.name) && release.type !== "none");
     if (releasingFixedPackages.length === 0) continue;
     let highestReleaseType = getHighestReleaseType(releasingFixedPackages);
-    let highestVersion = getCurrentHighestVersion(fixedPackages, packagesByName); // Finally, we update the packages so all of them are on the highest version
+    let highestVersion = getCurrentHighestVersion(fixedPackages, packagesByName);
 
+    // Finally, we update the packages so all of them are on the highest version
     for (let pkgName of fixedPackages) {
       if (config.ignore.includes(pkgName)) {
         continue;
       }
-
       let release = releases.get(pkgName);
-
       if (!release) {
         updated = true;
         releases.set(pkgName, {
@@ -371,19 +331,16 @@ function matchFixedConstraint(releases, packagesByName, config) {
         });
         continue;
       }
-
       if (release.type !== highestReleaseType) {
         updated = true;
         release.type = highestReleaseType;
       }
-
       if (release.oldVersion !== highestVersion) {
         updated = true;
         release.oldVersion = highestVersion;
       }
     }
   }
-
   return updated;
 }
 
@@ -399,47 +356,44 @@ function matchFixedConstraint(releases, packagesByName, config) {
   We could solve this by inlining this function, or by returning a deep-cloned then
   modified array, but we decided both of those are worse than this solution.
 */
-
 function applyLinks(releases, packagesByName, linked) {
-  let updated = false; // We do this for each set of linked packages
+  let updated = false;
 
+  // We do this for each set of linked packages
   for (let linkedPackages of linked) {
     // First we filter down to all the relevant releases for one set of linked packages
-    let releasingLinkedPackages = [...releases.values()].filter(release => linkedPackages.includes(release.name) && release.type !== "none"); // If we proceed any further we do extra work with calculating highestVersion for things that might
-    // not need one, as they only have workspace based packages
+    let releasingLinkedPackages = [...releases.values()].filter(release => linkedPackages.includes(release.name) && release.type !== "none");
 
+    // If we proceed any further we do extra work with calculating highestVersion for things that might
+    // not need one, as they only have workspace based packages
     if (releasingLinkedPackages.length === 0) continue;
     let highestReleaseType = getHighestReleaseType(releasingLinkedPackages);
-    let highestVersion = getCurrentHighestVersion(linkedPackages, packagesByName); // Finally, we update the packages so all of them are on the highest version
+    let highestVersion = getCurrentHighestVersion(linkedPackages, packagesByName);
 
+    // Finally, we update the packages so all of them are on the highest version
     for (let linkedPackage of releasingLinkedPackages) {
       if (linkedPackage.type !== highestReleaseType) {
         updated = true;
         linkedPackage.type = highestReleaseType;
       }
-
       if (linkedPackage.oldVersion !== highestVersion) {
         updated = true;
         linkedPackage.oldVersion = highestVersion;
       }
     }
   }
-
   return updated;
 }
 
 function getPreVersion(version) {
   let parsed = semver.parse(version);
   let preVersion = parsed.prerelease[1] === undefined ? -1 : parsed.prerelease[1];
-
   if (typeof preVersion !== "number") {
     throw new errors.InternalError("preVersion is not a number");
   }
-
   preVersion++;
   return preVersion;
 }
-
 function getSnapshotSuffix(template, snapshotParameters) {
   let snapshotRefDate = new Date();
   const placeholderValues = {
@@ -447,36 +401,32 @@ function getSnapshotSuffix(template, snapshotParameters) {
     tag: snapshotParameters.tag,
     timestamp: snapshotRefDate.getTime().toString(),
     datetime: snapshotRefDate.toISOString().replace(/\.\d{3}Z$/, "").replace(/[^\d]/g, "")
-  }; // We need a special handling because we need to handle a case where `--snapshot` is used without any template,
-  // and the resulting version needs to be composed without a tag.
+  };
 
+  // We need a special handling because we need to handle a case where `--snapshot` is used without any template,
+  // and the resulting version needs to be composed without a tag.
   if (!template) {
     return [placeholderValues.tag, placeholderValues.datetime].filter(Boolean).join("-");
   }
-
   const placeholders = Object.keys(placeholderValues);
-
   if (!template.includes(`{tag}`) && placeholderValues.tag !== undefined) {
     throw new Error(`Failed to compose snapshot version: "{tag}" placeholder is missing, but the snapshot parameter is defined (value: '${placeholderValues.tag}')`);
   }
-
   return placeholders.reduce((prev, key) => {
     return prev.replace(new RegExp(`\\{${key}\\}`, "g"), () => {
       const value = placeholderValues[key];
-
       if (value === undefined) {
         throw new Error(`Failed to compose snapshot version: "{${key}}" placeholder is used without having a value defined!`);
       }
-
       return value;
     });
   }, template);
 }
-
 function getSnapshotVersion(release, preInfo, useCalculatedVersion, snapshotSuffix) {
   if (release.type === "none") {
     return release.oldVersion;
   }
+
   /**
    * Using version as 0.0.0 so that it does not hinder with other version release
    * For example;
@@ -486,22 +436,53 @@ function getSnapshotVersion(release, preInfo, useCalculatedVersion, snapshotSuff
    *
    * You can set `snapshot.useCalculatedVersion` flag to true to use calculated versions if you don't care about the above problem.
    */
-
-
   const baseVersion = useCalculatedVersion ? incrementVersion(release, preInfo) : `0.0.0`;
   return `${baseVersion}-${snapshotSuffix}`;
 }
-
-function getNewVersion(release, preInfo) {
+function getNewVersion(release, preInfo, config) {
   if (release.type === "none") {
     return release.oldVersion;
   }
 
+  const customIncrement = getCustomIncrementVersionsFunc(release.name, config);
+  if (customIncrement) return customIncrement.incrementVersionsFuncs.incrementVersion(release.oldVersion, release.type, () => {
+    return incrementVersion(release, preInfo);
+  });
   return incrementVersion(release, preInfo);
 }
-
-function assembleReleasePlan(changesets, packages, config, // intentionally not using an optional parameter here so the result of `readPreState` has to be passed in here
-preState, // snapshot: undefined            ->  not using snaphot
+function getCustomIncrementVersionsFunc(pkgName, config) {
+  var _config$incrementVers, _config$incrementVers2;
+  if (!config.incrementVersions) {
+    return null;
+  }
+  const cwd = process.cwd();
+  let changesetPath = path__default['default'].join(cwd, ".changeset");
+  if (!((_config$incrementVers = config.incrementVersions) !== null && _config$incrementVers !== void 0 && (_config$incrementVers2 = _config$incrementVers[pkgName]) !== null && _config$incrementVers2 !== void 0 && _config$incrementVers2.path)) {
+    return null;
+  }
+  const incrementVersionsOpts = config.incrementVersions[pkgName];
+  let incrementVersionsPath = resolveFrom__default['default'](changesetPath, incrementVersionsOpts.path);
+  let incrementVersionsFuncs;
+  let possibleIncrementVersionFunc = require(incrementVersionsPath);
+  if (possibleIncrementVersionFunc.default) {
+    possibleIncrementVersionFunc = possibleIncrementVersionFunc.default;
+  }
+  if (typeof possibleIncrementVersionFunc.incrementVersion === "function") {
+    incrementVersionsFuncs = {
+      incrementVersion: possibleIncrementVersionFunc.incrementVersion
+    };
+  } else {
+    throw new Error("Could not resolve changelog generation functions");
+  }
+  return {
+    incrementVersionsOpts,
+    incrementVersionsFuncs
+  };
+}
+function assembleReleasePlan(changesets, packages, config,
+// intentionally not using an optional parameter here so the result of `readPreState` has to be passed in here
+preState,
+// snapshot: undefined            ->  not using snaphot
 // snapshot: { tag: undefined }   ->  --snapshot (empty tag)
 // snapshot: { tag: "canary" }    ->  --snapshot canary
 snapshot) {
@@ -520,16 +501,16 @@ snapshot) {
   } : snapshot;
   let packagesByName = new Map(packages.packages.map(x => [x.packageJson.name, x]));
   const relevantChangesets = getRelevantChangesets(changesets, refinedConfig.ignore, preState);
-  const preInfo = getPreInfo(changesets, packagesByName, refinedConfig, preState); // releases is, at this point a list of all packages we are going to releases,
+  const preInfo = getPreInfo(changesets, packagesByName, refinedConfig, preState);
+
+  // releases is, at this point a list of all packages we are going to releases,
   // flattened down to one release per package, having a reference back to their
   // changesets, and with a calculated new versions
-
   let releases = flattenReleases(relevantChangesets, packagesByName, refinedConfig.ignore);
   let dependencyGraph = getDependentsGraph.getDependentsGraph(packages, {
     bumpVersionsWithWorkspaceProtocolOnly: refinedConfig.bumpVersionsWithWorkspaceProtocolOnly
   });
   let releasesValidated = false;
-
   while (releasesValidated === false) {
     // The map passed in to determineDependents will be mutated
     let dependentAdded = determineDependents({
@@ -538,13 +519,13 @@ snapshot) {
       dependencyGraph,
       preInfo,
       config: refinedConfig
-    }); // `releases` might get mutated here
+    });
 
+    // `releases` might get mutated here
     let fixedConstraintUpdated = matchFixedConstraint(releases, packagesByName, refinedConfig);
     let linksUpdated = applyLinks(releases, packagesByName, refinedConfig.linked);
     releasesValidated = !linksUpdated && !dependentAdded && !fixedConstraintUpdated;
   }
-
   if ((preInfo === null || preInfo === void 0 ? void 0 : preInfo.state.mode) === "exit") {
     for (let pkg of packages.packages) {
       // If a package had a prerelease, but didn't trigger a version bump in the regular release,
@@ -552,7 +533,6 @@ snapshot) {
       // Detailed explanation at https://github.com/changesets/changesets/pull/382#discussion_r434434182
       if (preInfo.preVersions.get(pkg.packageJson.name) !== 0) {
         const existingRelease = releases.get(pkg.packageJson.name);
-
         if (!existingRelease) {
           releases.set(pkg.packageJson.name, {
             name: pkg.packageJson.name,
@@ -565,28 +545,26 @@ snapshot) {
         }
       }
     }
-  } // Caching the snapshot version here and use this if it is snapshot release
-
+  }
 
+  // Caching the snapshot version here and use this if it is snapshot release
   const snapshotSuffix = refinedSnapshot && getSnapshotSuffix(refinedConfig.snapshot.prereleaseTemplate, refinedSnapshot);
   return {
     changesets: relevantChangesets,
     releases: [...releases.values()].map(incompleteRelease => {
       return _objectSpread2(_objectSpread2({}, incompleteRelease), {}, {
-        newVersion: snapshotSuffix ? getSnapshotVersion(incompleteRelease, preInfo, refinedConfig.snapshot.useCalculatedVersion, snapshotSuffix) : getNewVersion(incompleteRelease, preInfo)
+        newVersion: snapshotSuffix ? getSnapshotVersion(incompleteRelease, preInfo, refinedConfig.snapshot.useCalculatedVersion, snapshotSuffix) : getNewVersion(incompleteRelease, preInfo, config)
       });
     }),
     preState: preInfo === null || preInfo === void 0 ? void 0 : preInfo.state
   };
 }
-
 function getRelevantChangesets(changesets, ignored, preState) {
   for (const changeset of changesets) {
     // Using the following 2 arrays to decide whether a changeset
     // contains both ignored and not ignored packages
     const ignoredPackages = [];
     const notIgnoredPackages = [];
-
     for (const release of changeset.releases) {
       if (ignored.find(ignoredPackageName => ignoredPackageName === release.name)) {
         ignoredPackages.push(release.name);
@@ -594,70 +572,54 @@ function getRelevantChangesets(changesets, ignored, preState) {
         notIgnoredPackages.push(release.name);
       }
     }
-
     if (ignoredPackages.length > 0 && notIgnoredPackages.length > 0) {
       throw new Error(`Found mixed changeset ${changeset.id}\n` + `Found ignored packages: ${ignoredPackages.join(" ")}\n` + `Found not ignored packages: ${notIgnoredPackages.join(" ")}\n` + "Mixed changesets that contain both ignored and not ignored packages are not allowed");
     }
   }
-
   if (preState && preState.mode !== "exit") {
     let usedChangesetIds = new Set(preState.changesets);
     return changesets.filter(changeset => !usedChangesetIds.has(changeset.id));
   }
-
   return changesets;
 }
-
 function getHighestPreVersion(packageGroup, packagesByName) {
   let highestPreVersion = 0;
-
   for (let pkg of packageGroup) {
     highestPreVersion = Math.max(getPreVersion(packagesByName.get(pkg).packageJson.version), highestPreVersion);
   }
-
   return highestPreVersion;
 }
-
 function getPreInfo(changesets, packagesByName, config, preState) {
   if (preState === undefined) {
     return;
   }
-
   let updatedPreState = _objectSpread2(_objectSpread2({}, preState), {}, {
     changesets: changesets.map(changeset => changeset.id),
     initialVersions: _objectSpread2({}, preState.initialVersions)
   });
-
   for (const [, pkg] of packagesByName) {
     if (updatedPreState.initialVersions[pkg.packageJson.name] === undefined) {
       updatedPreState.initialVersions[pkg.packageJson.name] = pkg.packageJson.version;
     }
-  } // Populate preVersion
+  }
+  // Populate preVersion
   // preVersion is the map between package name and its next pre version number.
-
-
   let preVersions = new Map();
-
   for (const [, pkg] of packagesByName) {
     preVersions.set(pkg.packageJson.name, getPreVersion(pkg.packageJson.version));
   }
-
   for (let fixedGroup of config.fixed) {
     let highestPreVersion = getHighestPreVersion(fixedGroup, packagesByName);
-
     for (let fixedPackage of fixedGroup) {
       preVersions.set(fixedPackage, highestPreVersion);
     }
   }
-
   for (let linkedGroup of config.linked) {
     let highestPreVersion = getHighestPreVersion(linkedGroup, packagesByName);
-
     for (let linkedPackage of linkedGroup) {
       preVersions.set(linkedPackage, highestPreVersion);
     }
   }
-
   return {
     state: updatedPreState,
     preVersions
diff --git a/node_modules/@changesets/assemble-release-plan/dist/assemble-release-plan.cjs.prod.js b/node_modules/@changesets/assemble-release-plan/dist/assemble-release-plan.cjs.prod.js
index 87b4c10..08a2fd6 100644
--- a/node_modules/@changesets/assemble-release-plan/dist/assemble-release-plan.cjs.prod.js
+++ b/node_modules/@changesets/assemble-release-plan/dist/assemble-release-plan.cjs.prod.js
@@ -4,7 +4,7 @@ Object.defineProperty(exports, "__esModule", {
   value: !0
 });
 
-var semver = require("semver"), errors = require("@changesets/errors"), getDependentsGraph = require("@changesets/get-dependents-graph");
+var semver = require("semver"), errors = require("@changesets/errors"), getDependentsGraph = require("@changesets/get-dependents-graph"), resolveFrom = require("resolve-from"), path = require("path");
 
 function _interopDefault(e) {
   return e && e.__esModule ? e : {
@@ -12,16 +12,7 @@ function _interopDefault(e) {
   };
 }
 
-var semver__default = _interopDefault(semver);
-
-function _defineProperty(obj, key, value) {
-  return key in obj ? Object.defineProperty(obj, key, {
-    value: value,
-    enumerable: !0,
-    configurable: !0,
-    writable: !0
-  }) : obj[key] = value, obj;
-}
+var semver__default = _interopDefault(semver), resolveFrom__default = _interopDefault(resolveFrom), path__default = _interopDefault(path);
 
 function ownKeys(object, enumerableOnly) {
   var keys = Object.keys(object);
@@ -46,6 +37,15 @@ function _objectSpread2(target) {
   return target;
 }
 
+function _defineProperty(obj, key, value) {
+  return key in obj ? Object.defineProperty(obj, key, {
+    value: value,
+    enumerable: !0,
+    configurable: !0,
+    writable: !0
+  }) : obj[key] = value, obj;
+}
+
 function incrementVersion(release, preInfo) {
   if ("none" === release.type) return release.oldVersion;
   let version = semver.inc(release.oldVersion, release.type);
@@ -242,8 +242,28 @@ function getSnapshotVersion(release, preInfo, useCalculatedVersion, snapshotSuff
   return `${useCalculatedVersion ? incrementVersion(release, preInfo) : "0.0.0"}-${snapshotSuffix}`;
 }
 
-function getNewVersion(release, preInfo) {
-  return "none" === release.type ? release.oldVersion : incrementVersion(release, preInfo);
+function getNewVersion(release, preInfo, config) {
+  if ("none" === release.type) return release.oldVersion;
+  const customIncrement = getCustomIncrementVersionsFunc(release.name, config);
+  return customIncrement ? customIncrement.incrementVersionsFuncs.incrementVersion(release.oldVersion, release.type, (() => incrementVersion(release, preInfo))) : incrementVersion(release, preInfo);
+}
+
+function getCustomIncrementVersionsFunc(pkgName, config) {
+  var _config$incrementVers, _config$incrementVers2;
+  if (!config.incrementVersions) return null;
+  const cwd = process.cwd();
+  let changesetPath = path__default.default.join(cwd, ".changeset");
+  if (null === (_config$incrementVers = config.incrementVersions) || void 0 === _config$incrementVers || null === (_config$incrementVers2 = _config$incrementVers[pkgName]) || void 0 === _config$incrementVers2 || !_config$incrementVers2.path) return null;
+  const incrementVersionsOpts = config.incrementVersions[pkgName];
+  let incrementVersionsFuncs, incrementVersionsPath = resolveFrom__default.default(changesetPath, incrementVersionsOpts.path), possibleIncrementVersionFunc = require(incrementVersionsPath);
+  if (possibleIncrementVersionFunc.default && (possibleIncrementVersionFunc = possibleIncrementVersionFunc.default), 
+  "function" != typeof possibleIncrementVersionFunc.incrementVersion) throw new Error("Could not resolve changelog generation functions");
+  return incrementVersionsFuncs = {
+    incrementVersion: possibleIncrementVersionFunc.incrementVersion
+  }, {
+    incrementVersionsOpts: incrementVersionsOpts,
+    incrementVersionsFuncs: incrementVersionsFuncs
+  };
 }
 
 function assembleReleasePlan(changesets, packages, config, preState, snapshot) {
@@ -285,7 +305,7 @@ function assembleReleasePlan(changesets, packages, config, preState, snapshot) {
   return {
     changesets: relevantChangesets,
     releases: [ ...releases.values() ].map((incompleteRelease => _objectSpread2(_objectSpread2({}, incompleteRelease), {}, {
-      newVersion: snapshotSuffix ? getSnapshotVersion(incompleteRelease, preInfo, refinedConfig.snapshot.useCalculatedVersion, snapshotSuffix) : getNewVersion(incompleteRelease, preInfo)
+      newVersion: snapshotSuffix ? getSnapshotVersion(incompleteRelease, preInfo, refinedConfig.snapshot.useCalculatedVersion, snapshotSuffix) : getNewVersion(incompleteRelease, preInfo, config)
     }))),
     preState: null == preInfo ? void 0 : preInfo.state
   };
diff --git a/node_modules/@changesets/assemble-release-plan/dist/assemble-release-plan.esm.js b/node_modules/@changesets/assemble-release-plan/dist/assemble-release-plan.esm.js
index c29c008..a07823e 100644
--- a/node_modules/@changesets/assemble-release-plan/dist/assemble-release-plan.esm.js
+++ b/node_modules/@changesets/assemble-release-plan/dist/assemble-release-plan.esm.js
@@ -1,75 +1,58 @@
 import semver, { inc, parse } from 'semver';
 import { InternalError } from '@changesets/errors';
 import { getDependentsGraph } from '@changesets/get-dependents-graph';
-
-function _defineProperty(obj, key, value) {
-  if (key in obj) {
-    Object.defineProperty(obj, key, {
-      value: value,
-      enumerable: true,
-      configurable: true,
-      writable: true
-    });
-  } else {
-    obj[key] = value;
-  }
-
-  return obj;
-}
+import resolveFrom from 'resolve-from';
+import path from 'path';
 
 function ownKeys(object, enumerableOnly) {
   var keys = Object.keys(object);
-
   if (Object.getOwnPropertySymbols) {
     var symbols = Object.getOwnPropertySymbols(object);
-    if (enumerableOnly) symbols = symbols.filter(function (sym) {
+    enumerableOnly && (symbols = symbols.filter(function (sym) {
       return Object.getOwnPropertyDescriptor(object, sym).enumerable;
-    });
-    keys.push.apply(keys, symbols);
+    })), keys.push.apply(keys, symbols);
   }
-
   return keys;
 }
-
 function _objectSpread2(target) {
   for (var i = 1; i < arguments.length; i++) {
-    var source = arguments[i] != null ? arguments[i] : {};
-
-    if (i % 2) {
-      ownKeys(Object(source), true).forEach(function (key) {
-        _defineProperty(target, key, source[key]);
-      });
-    } else if (Object.getOwnPropertyDescriptors) {
-      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
-    } else {
-      ownKeys(Object(source)).forEach(function (key) {
-        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
-      });
-    }
+    var source = null != arguments[i] ? arguments[i] : {};
+    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {
+      _defineProperty(target, key, source[key]);
+    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {
+      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
+    });
   }
-
   return target;
 }
+function _defineProperty(obj, key, value) {
+  if (key in obj) {
+    Object.defineProperty(obj, key, {
+      value: value,
+      enumerable: true,
+      configurable: true,
+      writable: true
+    });
+  } else {
+    obj[key] = value;
+  }
+  return obj;
+}
 
 function incrementVersion(release, preInfo) {
   if (release.type === "none") {
     return release.oldVersion;
   }
-
   let version = inc(release.oldVersion, release.type);
-
   if (preInfo !== undefined && preInfo.state.mode !== "exit") {
     let preVersion = preInfo.preVersions.get(release.name);
-
     if (preVersion === undefined) {
       throw new InternalError(`preVersion for ${release.name} does not exist when preState is defined`);
-    } // why are we adding this ourselves rather than passing 'pre' + versionType to semver.inc?
+    }
+    // why are we adding this ourselves rather than passing 'pre' + versionType to semver.inc?
     // because semver.inc with prereleases is confusing and this seems easier
-
-
     version += `-${preInfo.state.tag}.${preVersion}`;
   }
-
   return version;
 }
 
@@ -85,7 +68,6 @@ function incrementVersion(release, preInfo) {
   We could solve this by inlining this function, or by returning a deep-cloned then
   modified array, but we decided both of those are worse than this solution.
 */
-
 function determineDependents({
   releases,
   packagesByName,
@@ -93,31 +75,26 @@ function determineDependents({
   preInfo,
   config
 }) {
-  let updated = false; // NOTE this is intended to be called recursively
-
+  let updated = false;
+  // NOTE this is intended to be called recursively
   let pkgsToSearch = [...releases.values()];
-
   while (pkgsToSearch.length > 0) {
     // nextRelease is our dependency, think of it as "avatar"
     const nextRelease = pkgsToSearch.shift();
-    if (!nextRelease) continue; // pkgDependents will be a list of packages that depend on nextRelease ie. ['avatar-group', 'comment']
-
+    if (!nextRelease) continue;
+    // pkgDependents will be a list of packages that depend on nextRelease ie. ['avatar-group', 'comment']
     const pkgDependents = dependencyGraph.get(nextRelease.name);
-
     if (!pkgDependents) {
       throw new Error(`Error in determining dependents - could not find package in repository: ${nextRelease.name}`);
     }
-
     pkgDependents.map(dependent => {
       let type;
       const dependentPackage = packagesByName.get(dependent);
       if (!dependentPackage) throw new Error("Dependency map is incorrect");
-
       if (config.ignore.includes(dependent)) {
         type = "none";
       } else {
         const dependencyVersionRanges = getDependencyVersionRanges(dependentPackage.packageJson, nextRelease);
-
         for (const {
           depType,
           versionRange
@@ -142,9 +119,7 @@ function determineDependents({
                 if (type !== "major" && type !== "minor") {
                   type = "patch";
                 }
-
                 break;
-
               case "devDependencies":
                 {
                   // We don't need a version bump if the package is only in the devDependencies of the dependent package
@@ -156,11 +131,9 @@ function determineDependents({
           }
         }
       }
-
       if (releases.has(dependent) && releases.get(dependent).type === type) {
         type = undefined;
       }
-
       return {
         name: dependent,
         type,
@@ -173,7 +146,8 @@ function determineDependents({
     }) => {
       // At this point, we know if we are making a change
       updated = true;
-      const existing = releases.get(name); // For things that are being given a major bump, we check if we have already
+      const existing = releases.get(name);
+      // For things that are being given a major bump, we check if we have already
       // added them here. If we have, we update the existing item instead of pushing it on to search.
       // It is safe to not add it to pkgsToSearch because it should have already been searched at the
       // largest possible bump type.
@@ -193,31 +167,29 @@ function determineDependents({
       }
     });
   }
-
   return updated;
 }
+
 /*
   Returns an array of objects in the shape { depType: DependencyType, versionRange: string }
   The array can contain more than one elements in case a dependency appears in multiple
   dependency lists. For example, a package that is both a peerDepenency and a devDependency.
 */
-
 function getDependencyVersionRanges(dependentPkgJSON, dependencyRelease) {
   const DEPENDENCY_TYPES = ["dependencies", "devDependencies", "peerDependencies", "optionalDependencies"];
   const dependencyVersionRanges = [];
-
   for (const type of DEPENDENCY_TYPES) {
     var _dependentPkgJSON$typ;
-
     const versionRange = (_dependentPkgJSON$typ = dependentPkgJSON[type]) === null || _dependentPkgJSON$typ === void 0 ? void 0 : _dependentPkgJSON$typ[dependencyRelease.name];
     if (!versionRange) continue;
-
     if (versionRange.startsWith("workspace:")) {
       dependencyVersionRanges.push({
         depType: type,
-        versionRange: // intentionally keep other workspace ranges untouched
+        versionRange:
+        // intentionally keep other workspace ranges untouched
         // this has to be fixed but this should only be done when adding appropriate tests
-        versionRange === "workspace:*" ? // workspace:* actually means the current exact version, and not a wildcard similar to a reguler * range
+        versionRange === "workspace:*" ?
+        // workspace:* actually means the current exact version, and not a wildcard similar to a reguler * range
         dependencyRelease.oldVersion : versionRange.replace(/^workspace:/, "")
       });
     } else {
@@ -227,10 +199,8 @@ function getDependencyVersionRanges(dependentPkgJSON, dependencyRelease) {
       });
     }
   }
-
   return dependencyVersionRanges;
 }
-
 function shouldBumpMajor({
   dependent,
   depType,
@@ -241,18 +211,22 @@ function shouldBumpMajor({
   onlyUpdatePeerDependentsWhenOutOfRange
 }) {
   // we check if it is a peerDependency because if it is, our dependent bump type might need to be major.
-  return depType === "peerDependencies" && nextRelease.type !== "none" && nextRelease.type !== "patch" && ( // 1. If onlyUpdatePeerDependentsWhenOutOfRange set to true, bump major if the version is leaving the range.
+  return depType === "peerDependencies" && nextRelease.type !== "none" && nextRelease.type !== "patch" && (
+  // 1. If onlyUpdatePeerDependentsWhenOutOfRange set to true, bump major if the version is leaving the range.
   // 2. If onlyUpdatePeerDependentsWhenOutOfRange set to false, bump major regardless whether or not the version is leaving the range.
-  !onlyUpdatePeerDependentsWhenOutOfRange || !semver.satisfies(incrementVersion(nextRelease, preInfo), versionRange)) && ( // bump major only if the dependent doesn't already has a major release.
+  !onlyUpdatePeerDependentsWhenOutOfRange || !semver.satisfies(incrementVersion(nextRelease, preInfo), versionRange)) && (
+  // bump major only if the dependent doesn't already has a major release.
   !releases.has(dependent) || releases.has(dependent) && releases.get(dependent).type !== "major");
 }
 
 // This function takes in changesets and returns one release per
 // package listed in the changesets
+
 function flattenReleases(changesets, packagesByName, ignoredPackages) {
   let releases = new Map();
   changesets.forEach(changeset => {
-    changeset.releases // Filter out ignored packages because they should not trigger a release
+    changeset.releases
+    // Filter out ignored packages because they should not trigger a release
     // If their dependencies need updates, they will be added to releases by `determineDependents()` with release type `none`
     .filter(({
       name
@@ -262,11 +236,9 @@ function flattenReleases(changesets, packagesByName, ignoredPackages) {
     }) => {
       let release = releases.get(name);
       let pkg = packagesByName.get(name);
-
       if (!pkg) {
         throw new Error(`"${changeset.id}" changeset mentions a release for a package "${name}" but such a package could not be found.`);
       }
-
       if (!release) {
         release = {
           name,
@@ -277,14 +249,12 @@ function flattenReleases(changesets, packagesByName, ignoredPackages) {
       } else {
         if (type === "major" || (release.type === "patch" || release.type === "none") && (type === "minor" || type === "patch")) {
           release.type = type;
-        } // Check whether the bumpType will change
+        }
+        // Check whether the bumpType will change
         // If the bumpType has changed recalc newVersion
         // push new changeset to releases
-
-
         release.changesets.push(changeset.id);
       }
-
       releases.set(name, release);
     });
   });
@@ -295,64 +265,52 @@ function getHighestReleaseType(releases) {
   if (releases.length === 0) {
     throw new Error(`Large internal Changesets error when calculating highest release type in the set of releases. Please contact the maintainers`);
   }
-
   let highestReleaseType = "none";
-
   for (let release of releases) {
     switch (release.type) {
       case "major":
         return "major";
-
       case "minor":
         highestReleaseType = "minor";
         break;
-
       case "patch":
         if (highestReleaseType === "none") {
           highestReleaseType = "patch";
         }
-
         break;
     }
   }
-
   return highestReleaseType;
 }
 function getCurrentHighestVersion(packageGroup, packagesByName) {
   let highestVersion;
-
   for (let pkgName of packageGroup) {
     let pkg = packagesByName.get(pkgName);
-
     if (!pkg) {
       console.error(`FATAL ERROR IN CHANGESETS! We were unable to version for package group: ${pkgName} in package group: ${packageGroup.toString()}`);
       throw new Error(`fatal: could not resolve linked packages`);
     }
-
     if (highestVersion === undefined || semver.gt(pkg.packageJson.version, highestVersion)) {
       highestVersion = pkg.packageJson.version;
     }
   }
-
   return highestVersion;
 }
 
 function matchFixedConstraint(releases, packagesByName, config) {
   let updated = false;
-
   for (let fixedPackages of config.fixed) {
     let releasingFixedPackages = [...releases.values()].filter(release => fixedPackages.includes(release.name) && release.type !== "none");
     if (releasingFixedPackages.length === 0) continue;
     let highestReleaseType = getHighestReleaseType(releasingFixedPackages);
-    let highestVersion = getCurrentHighestVersion(fixedPackages, packagesByName); // Finally, we update the packages so all of them are on the highest version
+    let highestVersion = getCurrentHighestVersion(fixedPackages, packagesByName);
 
+    // Finally, we update the packages so all of them are on the highest version
     for (let pkgName of fixedPackages) {
       if (config.ignore.includes(pkgName)) {
         continue;
       }
-
       let release = releases.get(pkgName);
-
       if (!release) {
         updated = true;
         releases.set(pkgName, {
@@ -363,19 +321,16 @@ function matchFixedConstraint(releases, packagesByName, config) {
         });
         continue;
       }
-
       if (release.type !== highestReleaseType) {
         updated = true;
         release.type = highestReleaseType;
       }
-
       if (release.oldVersion !== highestVersion) {
         updated = true;
         release.oldVersion = highestVersion;
       }
     }
   }
-
   return updated;
 }
 
@@ -391,47 +346,44 @@ function matchFixedConstraint(releases, packagesByName, config) {
   We could solve this by inlining this function, or by returning a deep-cloned then
   modified array, but we decided both of those are worse than this solution.
 */
-
 function applyLinks(releases, packagesByName, linked) {
-  let updated = false; // We do this for each set of linked packages
+  let updated = false;
 
+  // We do this for each set of linked packages
   for (let linkedPackages of linked) {
     // First we filter down to all the relevant releases for one set of linked packages
-    let releasingLinkedPackages = [...releases.values()].filter(release => linkedPackages.includes(release.name) && release.type !== "none"); // If we proceed any further we do extra work with calculating highestVersion for things that might
-    // not need one, as they only have workspace based packages
+    let releasingLinkedPackages = [...releases.values()].filter(release => linkedPackages.includes(release.name) && release.type !== "none");
 
+    // If we proceed any further we do extra work with calculating highestVersion for things that might
+    // not need one, as they only have workspace based packages
     if (releasingLinkedPackages.length === 0) continue;
     let highestReleaseType = getHighestReleaseType(releasingLinkedPackages);
-    let highestVersion = getCurrentHighestVersion(linkedPackages, packagesByName); // Finally, we update the packages so all of them are on the highest version
+    let highestVersion = getCurrentHighestVersion(linkedPackages, packagesByName);
 
+    // Finally, we update the packages so all of them are on the highest version
     for (let linkedPackage of releasingLinkedPackages) {
       if (linkedPackage.type !== highestReleaseType) {
         updated = true;
         linkedPackage.type = highestReleaseType;
       }
-
       if (linkedPackage.oldVersion !== highestVersion) {
         updated = true;
         linkedPackage.oldVersion = highestVersion;
       }
     }
   }
-
   return updated;
 }
 
 function getPreVersion(version) {
   let parsed = parse(version);
   let preVersion = parsed.prerelease[1] === undefined ? -1 : parsed.prerelease[1];
-
   if (typeof preVersion !== "number") {
     throw new InternalError("preVersion is not a number");
   }
-
   preVersion++;
   return preVersion;
 }
-
 function getSnapshotSuffix(template, snapshotParameters) {
   let snapshotRefDate = new Date();
   const placeholderValues = {
@@ -439,36 +391,32 @@ function getSnapshotSuffix(template, snapshotParameters) {
     tag: snapshotParameters.tag,
     timestamp: snapshotRefDate.getTime().toString(),
     datetime: snapshotRefDate.toISOString().replace(/\.\d{3}Z$/, "").replace(/[^\d]/g, "")
-  }; // We need a special handling because we need to handle a case where `--snapshot` is used without any template,
-  // and the resulting version needs to be composed without a tag.
+  };
 
+  // We need a special handling because we need to handle a case where `--snapshot` is used without any template,
+  // and the resulting version needs to be composed without a tag.
   if (!template) {
     return [placeholderValues.tag, placeholderValues.datetime].filter(Boolean).join("-");
   }
-
   const placeholders = Object.keys(placeholderValues);
-
   if (!template.includes(`{tag}`) && placeholderValues.tag !== undefined) {
     throw new Error(`Failed to compose snapshot version: "{tag}" placeholder is missing, but the snapshot parameter is defined (value: '${placeholderValues.tag}')`);
   }
-
   return placeholders.reduce((prev, key) => {
     return prev.replace(new RegExp(`\\{${key}\\}`, "g"), () => {
       const value = placeholderValues[key];
-
       if (value === undefined) {
         throw new Error(`Failed to compose snapshot version: "{${key}}" placeholder is used without having a value defined!`);
       }
-
       return value;
     });
   }, template);
 }
-
 function getSnapshotVersion(release, preInfo, useCalculatedVersion, snapshotSuffix) {
   if (release.type === "none") {
     return release.oldVersion;
   }
+
   /**
    * Using version as 0.0.0 so that it does not hinder with other version release
    * For example;
@@ -478,22 +426,52 @@ function getSnapshotVersion(release, preInfo, useCalculatedVersion, snapshotSuff
    *
    * You can set `snapshot.useCalculatedVersion` flag to true to use calculated versions if you don't care about the above problem.
    */
-
-
   const baseVersion = useCalculatedVersion ? incrementVersion(release, preInfo) : `0.0.0`;
   return `${baseVersion}-${snapshotSuffix}`;
 }
-
-function getNewVersion(release, preInfo) {
+function getNewVersion(release, preInfo, config) {
   if (release.type === "none") {
     return release.oldVersion;
   }
-
+  const customIncrement = getCustomIncrementVersionsFunc(release.name, config);
+  if (customIncrement) return customIncrement.incrementVersionsFuncs.incrementVersion(release.oldVersion, release.type, () => {
+    return incrementVersion(release, preInfo);
+  });
   return incrementVersion(release, preInfo);
 }
-
-function assembleReleasePlan(changesets, packages, config, // intentionally not using an optional parameter here so the result of `readPreState` has to be passed in here
-preState, // snapshot: undefined            ->  not using snaphot
+function getCustomIncrementVersionsFunc(pkgName, config) {
+  var _config$incrementVers, _config$incrementVers2;
+  if (!config.incrementVersions) {
+    return null;
+  }
+  const cwd = process.cwd();
+  let changesetPath = path.join(cwd, ".changeset");
+  if (!((_config$incrementVers = config.incrementVersions) !== null && _config$incrementVers !== void 0 && (_config$incrementVers2 = _config$incrementVers[pkgName]) !== null && _config$incrementVers2 !== void 0 && _config$incrementVers2.path)) {
+    return null;
+  }
+  const incrementVersionsOpts = config.incrementVersions[pkgName];
+  let incrementVersionsPath = resolveFrom(changesetPath, incrementVersionsOpts.path);
+  let incrementVersionsFuncs;
+  let possibleIncrementVersionFunc = require(incrementVersionsPath);
+  if (possibleIncrementVersionFunc.default) {
+    possibleIncrementVersionFunc = possibleIncrementVersionFunc.default;
+  }
+  if (typeof possibleIncrementVersionFunc.incrementVersion === "function") {
+    incrementVersionsFuncs = {
+      incrementVersion: possibleIncrementVersionFunc.incrementVersion
+    };
+  } else {
+    throw new Error("Could not resolve changelog generation functions");
+  }
+  return {
+    incrementVersionsOpts,
+    incrementVersionsFuncs
+  };
+}
+function assembleReleasePlan(changesets, packages, config,
+// intentionally not using an optional parameter here so the result of `readPreState` has to be passed in here
+preState,
+// snapshot: undefined            ->  not using snaphot
 // snapshot: { tag: undefined }   ->  --snapshot (empty tag)
 // snapshot: { tag: "canary" }    ->  --snapshot canary
 snapshot) {
@@ -512,16 +490,16 @@ snapshot) {
   } : snapshot;
   let packagesByName = new Map(packages.packages.map(x => [x.packageJson.name, x]));
   const relevantChangesets = getRelevantChangesets(changesets, refinedConfig.ignore, preState);
-  const preInfo = getPreInfo(changesets, packagesByName, refinedConfig, preState); // releases is, at this point a list of all packages we are going to releases,
+  const preInfo = getPreInfo(changesets, packagesByName, refinedConfig, preState);
+
+  // releases is, at this point a list of all packages we are going to releases,
   // flattened down to one release per package, having a reference back to their
   // changesets, and with a calculated new versions
-
   let releases = flattenReleases(relevantChangesets, packagesByName, refinedConfig.ignore);
   let dependencyGraph = getDependentsGraph(packages, {
     bumpVersionsWithWorkspaceProtocolOnly: refinedConfig.bumpVersionsWithWorkspaceProtocolOnly
   });
   let releasesValidated = false;
-
   while (releasesValidated === false) {
     // The map passed in to determineDependents will be mutated
     let dependentAdded = determineDependents({
@@ -530,13 +508,13 @@ snapshot) {
       dependencyGraph,
       preInfo,
       config: refinedConfig
-    }); // `releases` might get mutated here
+    });
 
+    // `releases` might get mutated here
     let fixedConstraintUpdated = matchFixedConstraint(releases, packagesByName, refinedConfig);
     let linksUpdated = applyLinks(releases, packagesByName, refinedConfig.linked);
     releasesValidated = !linksUpdated && !dependentAdded && !fixedConstraintUpdated;
   }
-
   if ((preInfo === null || preInfo === void 0 ? void 0 : preInfo.state.mode) === "exit") {
     for (let pkg of packages.packages) {
       // If a package had a prerelease, but didn't trigger a version bump in the regular release,
@@ -544,7 +522,6 @@ snapshot) {
       // Detailed explanation at https://github.com/changesets/changesets/pull/382#discussion_r434434182
       if (preInfo.preVersions.get(pkg.packageJson.name) !== 0) {
         const existingRelease = releases.get(pkg.packageJson.name);
-
         if (!existingRelease) {
           releases.set(pkg.packageJson.name, {
             name: pkg.packageJson.name,
@@ -557,28 +534,26 @@ snapshot) {
         }
       }
     }
-  } // Caching the snapshot version here and use this if it is snapshot release
-
+  }
 
+  // Caching the snapshot version here and use this if it is snapshot release
   const snapshotSuffix = refinedSnapshot && getSnapshotSuffix(refinedConfig.snapshot.prereleaseTemplate, refinedSnapshot);
   return {
     changesets: relevantChangesets,
     releases: [...releases.values()].map(incompleteRelease => {
       return _objectSpread2(_objectSpread2({}, incompleteRelease), {}, {
-        newVersion: snapshotSuffix ? getSnapshotVersion(incompleteRelease, preInfo, refinedConfig.snapshot.useCalculatedVersion, snapshotSuffix) : getNewVersion(incompleteRelease, preInfo)
+        newVersion: snapshotSuffix ? getSnapshotVersion(incompleteRelease, preInfo, refinedConfig.snapshot.useCalculatedVersion, snapshotSuffix) : getNewVersion(incompleteRelease, preInfo, config)
       });
     }),
     preState: preInfo === null || preInfo === void 0 ? void 0 : preInfo.state
   };
 }
-
 function getRelevantChangesets(changesets, ignored, preState) {
   for (const changeset of changesets) {
     // Using the following 2 arrays to decide whether a changeset
     // contains both ignored and not ignored packages
     const ignoredPackages = [];
     const notIgnoredPackages = [];
-
     for (const release of changeset.releases) {
       if (ignored.find(ignoredPackageName => ignoredPackageName === release.name)) {
         ignoredPackages.push(release.name);
@@ -586,70 +561,54 @@ function getRelevantChangesets(changesets, ignored, preState) {
         notIgnoredPackages.push(release.name);
       }
     }
-
     if (ignoredPackages.length > 0 && notIgnoredPackages.length > 0) {
       throw new Error(`Found mixed changeset ${changeset.id}\n` + `Found ignored packages: ${ignoredPackages.join(" ")}\n` + `Found not ignored packages: ${notIgnoredPackages.join(" ")}\n` + "Mixed changesets that contain both ignored and not ignored packages are not allowed");
     }
   }
-
   if (preState && preState.mode !== "exit") {
     let usedChangesetIds = new Set(preState.changesets);
     return changesets.filter(changeset => !usedChangesetIds.has(changeset.id));
   }
-
   return changesets;
 }
-
 function getHighestPreVersion(packageGroup, packagesByName) {
   let highestPreVersion = 0;
-
   for (let pkg of packageGroup) {
     highestPreVersion = Math.max(getPreVersion(packagesByName.get(pkg).packageJson.version), highestPreVersion);
   }
-
   return highestPreVersion;
 }
-
 function getPreInfo(changesets, packagesByName, config, preState) {
   if (preState === undefined) {
     return;
   }
-
   let updatedPreState = _objectSpread2(_objectSpread2({}, preState), {}, {
     changesets: changesets.map(changeset => changeset.id),
     initialVersions: _objectSpread2({}, preState.initialVersions)
   });
-
   for (const [, pkg] of packagesByName) {
     if (updatedPreState.initialVersions[pkg.packageJson.name] === undefined) {
       updatedPreState.initialVersions[pkg.packageJson.name] = pkg.packageJson.version;
     }
-  } // Populate preVersion
+  }
+  // Populate preVersion
   // preVersion is the map between package name and its next pre version number.
-
-
   let preVersions = new Map();
-
   for (const [, pkg] of packagesByName) {
     preVersions.set(pkg.packageJson.name, getPreVersion(pkg.packageJson.version));
   }
-
   for (let fixedGroup of config.fixed) {
     let highestPreVersion = getHighestPreVersion(fixedGroup, packagesByName);
-
     for (let fixedPackage of fixedGroup) {
       preVersions.set(fixedPackage, highestPreVersion);
     }
   }
-
   for (let linkedGroup of config.linked) {
     let highestPreVersion = getHighestPreVersion(linkedGroup, packagesByName);
-
     for (let linkedPackage of linkedGroup) {
       preVersions.set(linkedPackage, highestPreVersion);
     }
   }
-
   return {
     state: updatedPreState,
     preVersions
diff --git a/node_modules/@changesets/assemble-release-plan/src/index.test.ts b/node_modules/@changesets/assemble-release-plan/src/index.test.ts
index 24d9583..0d24595 100644
--- a/node_modules/@changesets/assemble-release-plan/src/index.test.ts
+++ b/node_modules/@changesets/assemble-release-plan/src/index.test.ts
@@ -1,6 +1,8 @@
 import { defaultConfig } from "@changesets/config";
+import { Config } from "@changesets/types";
 import assembleReleasePlan from "./";
 import FakeFullState from "./test-utils";
+import path from "path";
 
 describe("assemble-release-plan", () => {
   let setup: FakeFullState;
@@ -13,6 +15,57 @@ describe("assemble-release-plan", () => {
     setup.addPackage("pkg-d", "1.0.0");
   });
 
+  it("should run func", () => {
+    setup = new FakeFullState();
+
+    setup.addPackage("pkg-b", "2023.1.0");
+    setup.addPackage("pkg-c", "2023.10.0");
+    setup.addPackage("pkg-d", "2023.10.0");
+
+    setup.addChangeset({
+      id: "big-cats-delight",
+      releases: [
+        { name: "pkg-a", type: "major" },
+        { name: "pkg-b", type: "major" },
+        { name: "pkg-c", type: "major" },
+        { name: "pkg-d", type: "major" },
+      ],
+    });
+
+    const newConfig: Config = {
+      ...defaultConfig,
+      incrementVersions: {
+        "pkg-b": {
+          path: path.resolve(__dirname, "test-utils/version-file.ts"),
+        },
+        "pkg-c": {
+          path: path.resolve(__dirname, "test-utils/version-file.ts"),
+        },
+      },
+    };
+
+    let { releases } = assembleReleasePlan(
+      setup.changesets,
+      setup.packages,
+      newConfig,
+      undefined
+    );
+
+    expect(releases.length).toBe(4);
+    expect(releases[0].name).toBe("pkg-a");
+    expect(releases[0].newVersion).toBe("2.0.0");
+
+    expect(releases[1].name).toBe("pkg-b");
+    expect(releases[1].newVersion).toBe("2023.4.0");
+
+    expect(releases[2].name).toBe("pkg-c");
+    expect(releases[2].newVersion).toBe("2024.1.0");
+
+    // no custom calver control
+    expect(releases[3].name).toBe("pkg-d");
+    expect(releases[3].newVersion).toBe("2024.0.0");
+  });
+
   it("should assemble release plan for basic setup", () => {
     let { releases } = assembleReleasePlan(
       setup.changesets,
diff --git a/node_modules/@changesets/assemble-release-plan/src/index.ts b/node_modules/@changesets/assemble-release-plan/src/index.ts
index 3ffb6fa..5882569 100644
--- a/node_modules/@changesets/assemble-release-plan/src/index.ts
+++ b/node_modules/@changesets/assemble-release-plan/src/index.ts
@@ -4,6 +4,7 @@ import {
   NewChangeset,
   PreState,
   PackageGroup,
+  IncrementVersionsFunctions,
 } from "@changesets/types";
 import determineDependents from "./determine-dependents";
 import flattenReleases from "./flatten-releases";
@@ -15,6 +16,8 @@ import { InternalError } from "@changesets/errors";
 import { Packages, Package } from "@manypkg/get-packages";
 import { getDependentsGraph } from "@changesets/get-dependents-graph";
 import { PreInfo, InternalRelease } from "./types";
+import resolveFrom from "resolve-from";
+import path from "path";
 
 type SnapshotReleaseParameters = {
   tag?: string | undefined;
@@ -108,15 +111,69 @@ function getSnapshotVersion(
 
 function getNewVersion(
   release: InternalRelease,
-  preInfo: PreInfo | undefined
+  preInfo: PreInfo | undefined,
+  config: OptionalProp<Config, "snapshot">
 ): string {
   if (release.type === "none") {
     return release.oldVersion;
   }
 
+  const customIncrement = getCustomIncrementVersionsFunc(release.name, config);
+
+  if (customIncrement)
+    return customIncrement.incrementVersionsFuncs.incrementVersion(
+      release.oldVersion,
+      release.type,
+      () => {
+        return incrementVersion(release, preInfo);
+      }
+    );
+
   return incrementVersion(release, preInfo);
 }
 
+function getCustomIncrementVersionsFunc(
+  pkgName: string,
+  config: OptionalProp<Config, "snapshot">
+): {
+  incrementVersionsOpts: any;
+  incrementVersionsFuncs: IncrementVersionsFunctions;
+} | null {
+  if (!config.incrementVersions) {
+    return null;
+  }
+
+  const cwd = process.cwd();
+  let changesetPath = path.join(cwd, ".changeset");
+
+  if (!config.incrementVersions?.[pkgName]?.path) {
+    return null;
+  }
+
+  const incrementVersionsOpts = config.incrementVersions[pkgName];
+
+  let incrementVersionsPath = resolveFrom(
+    changesetPath,
+    incrementVersionsOpts.path
+  );
+
+  let incrementVersionsFuncs: IncrementVersionsFunctions;
+  let possibleIncrementVersionFunc = require(incrementVersionsPath);
+  if (possibleIncrementVersionFunc.default) {
+    possibleIncrementVersionFunc = possibleIncrementVersionFunc.default;
+  }
+
+  if (typeof possibleIncrementVersionFunc.incrementVersion === "function") {
+    incrementVersionsFuncs = {
+      incrementVersion: possibleIncrementVersionFunc.incrementVersion,
+    };
+  } else {
+    throw new Error("Could not resolve changelog generation functions");
+  }
+
+  return { incrementVersionsOpts, incrementVersionsFuncs };
+}
+
 type OptionalProp<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;
 
 function assembleReleasePlan(
@@ -252,7 +309,7 @@ function assembleReleasePlan(
               refinedConfig.snapshot.useCalculatedVersion,
               snapshotSuffix
             )
-          : getNewVersion(incompleteRelease, preInfo),
+          : getNewVersion(incompleteRelease, preInfo, config),
       };
     }),
     preState: preInfo?.state,
diff --git a/node_modules/@changesets/assemble-release-plan/src/test-utils/version-file.ts b/node_modules/@changesets/assemble-release-plan/src/test-utils/version-file.ts
new file mode 100644
index 0000000..6e25676
--- /dev/null
+++ b/node_modules/@changesets/assemble-release-plan/src/test-utils/version-file.ts
@@ -0,0 +1,25 @@
+const incrementVersion = (
+  oldVersion: string,
+  type: string,
+  defaultIncreaseVersion: () => string
+) => {
+  const versions = oldVersion.split(".");
+  if (type === "major") {
+    const minor = parseInt(versions[1]);
+    const newMinor = (minor + 3) % 12;
+
+    const major = parseInt(versions[0]);
+    const newMajor = newMinor === 1 ? major + 1 : major;
+    return `${newMajor}.${newMinor}.0`;
+  }
+
+  if (type === "minor") {
+    return defaultIncreaseVersion();
+  }
+
+  return defaultIncreaseVersion();
+};
+
+export default {
+  incrementVersion,
+};
